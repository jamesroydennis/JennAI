#!/usr/bin/env python
import sys
import os
from pathlib import Path
import shutil
import sqlite3

# --- Root Project Path Setup (CRITICAL for Imports) ---
CONFIG_DIR = Path(__file__).resolve().parent.parent / "config"
if str(CONFIG_DIR) not in sys.path:
    sys.path.insert(0, str(CONFIG_DIR))

# Import PROJECT_ROOT from config/conf.py
try:
    from config.conf import PROJECT_ROOT
except ImportError:
    print("Error: Could not import PROJECT_ROOT from config/conf.py.")
    print("Please ensure config/conf.py exists and defines PROJECT_ROOT correctly.")
    sys.exit(1)

# Ensure the overall project root is in sys.path
if str(PROJECT_ROOT) not in sys.path:
    sys.path.insert(0, str(PROJECT_ROOT))

# --- InquirerPy for CLI UI ---
try:
    from InquirerPy import inquirer
    from InquirerPy.base.control import Choice
    from InquirerPy.separator import Separator
    from InquirerPy.utils import color_print
except ImportError:
    print("Error: InquirerPy is not installed or not found in the current environment.")
    print("Please ensure your conda environment is active and the package is installed.")
    print("You can try running: pip install InquirerPy")
    sys.exit(1)

# --- Configuration for Data Sample Location ---
SAMPLES_ROOT = PROJECT_ROOT / "src" / "data" / "samples"
LLM_SAMPLES_DIR = SAMPLES_ROOT / "llm"
MOCK_LLM_FILE = LLM_SAMPLES_DIR / "mock_llms.py"

# --- MockLLM Class Content (for mock_llms.py) ---
MOCK_LLM_CONTENT = """
import random

class MockLLM:
    \"\"\"
    A conceptual mock LLM with limited data for simulation purposes.
    Does not perform actual calculations or complex inferences.
    \"\"\"
    def __init__(self, name: str, domain: str, limited_data_focus: str):
        self.name = name
        self.domain = domain
        self.limited_data_focus = limited_data_focus
        self._id = f"{domain.split()[0].lower()}-{name.replace(' ', '-').lower()}"

    def infer(self, query: str) -> str:
        query_lower = query.lower()
        if self.limited_data_focus.lower() in query_lower:
            return (f"[{self.name} - {self.domain}]: My limited data strongly suggests a connection "
                    f"to '{self.limited_data_focus}' based on your query about '{query}'.")
        elif "general" in query_lower or "overview" in query_lower:
            return (f"[{self.name} - {self.domain}]: I can offer a general overview related to '{query}', "
                    f"drawing from my understanding of {self.domain}.")
        else:
            possible_unknown_responses = [
                f"[{self.name} - {self.domain}]: My data does not contain sufficient information to infer precisely about '{query}'.",
                f"[{self.name} - {self.domain}]: This specific query about '{query}' seems outside my current limited scope.",
                f"[{self.name} - {self.domain}]: I lack the specific patterns to accurately respond to '{query}'.",
                f"[{self.name} - {self.domain}]: (Simulating 'I don't know' for: '{query}'). My current knowledge base is restricted."
            ]
            return random.choice(possible_unknown_responses)

    def explain_inference(self, query: str, response: str) -> str:
        if "My data does not contain" in response or "outside my scope" in response or "I lack the specific patterns" in response:
             return f"[{self.name} - Explanation]: The previous response for '{query}' indicated a knowledge gap because it fell outside my limited data focus on '{self.limited_data_focus}' within the {self.domain} domain."
        elif "strongly suggests a connection" in response:
            return (f"[{self.name} - Explanation]: My inference for '{query}' was strongly driven by the presence of patterns related to "
                    f"'{self.limited_data_focus}' within my {self.domain} knowledge base. This is a direct match within my limited datasets.")
        else:
            return (f"[{self.name} - Explanation]: The general overview for '{query}' was generated by synthesizing high-level concepts from "
                    f"my {self.name}'s {self.domain} domain knowledge.")

    def __repr__(self):
        return f"MockLLM(name='{self.name}', domain='{self.domain}', focus='{self.limited_data_focus}')"
"""

# --- Mock LLM Data for DB ---
_cellular_biology_data = [
    ("BioBot Alpha", "Cellular Biology", "chloroplast function"),
    ("MitoMind", "Cellular Biology", "ATP synthesis"),
    ("CytoClone 3", "Cellular Biology", "glycolysis pathway"),
    ("PhotosynthAI", "Cellular Biology", "light-dependent reactions"),
    ("KrebsLogic", "Cellular Biology", "citric acid cycle enzymes"),
    ("EnzymeGen", "Cellular Biology", "protein folding in organelles"),
    ("GeneLinker", "Cellular Biology", "DNA replication stages"),
    ("MembraneMind", "Cellular Biology", "cell membrane transport"),
    ("RibosomeAI", "Cellular Biology", "mRNA translation"),
    ("CellCycleX", "Cellular Biology", "mitosis checkpoints"),
]
_cosmology_data = [
    ("CosmoComp", "Cosmology", "dark matter distribution"),
    ("GalaxyForge", "Cosmology", "spiral arm formation"),
    ("StarBirthAI", "Cosmology", "stellar nursery dynamics"),
    ("BlackHoleNet", "Cosmology", "accretion disk physics"),
    ("UniverseSim 7", "Cosmology", "cosmic microwave background"),
    ("ClusterMind", "Cosmology", "galaxy cluster mergers"),
    ("RedshiftAI", "Cosmology", "Hubble constant values"),
    ("Gravitron", "Cosmology", "large-scale structure growth"),
    ("QuasarSense", "Cosmology", "active galactic nuclei"),
    ("NebulaGen", "Cosmology", "interstellar medium properties"),
]
_human_biology_data = [
    ("NeuroConnect", "Human Biology", "neurotransmitter pathways"),
    ("CardioSys", "Human Biology", "cardiac cycle mechanics"),
    ("ImmunoNet", "Human Biology", "T-cell activation"),
    ("RenalFlow", "Human Biology", "nephron filtration"),
    ("HormoneAI", "Human Biology", "endocrine feedback loops"),
    ("MusculoMind", "Human Biology", "sarcomere contraction"),
    ("HepaticGen", "Human Biology", "liver detoxification enzymes"),
    ("DermoScan", "Human Biology", "skin barrier function"),
    ("BoneSynth", "Human Biology", "osteoblast activity"),
    ("VascNet", "Human Biology", "blood vessel elasticity"),
]
ALL_MOCK_LLMS_LIST = _cellular_biology_data + _cosmology_data + _human_biology_data

# --- Database Schema Content ---
DB_SCHEMA_CONTENT = """
PRAGMA foreign_keys = ON;

DROP TABLE IF EXISTS models;
CREATE TABLE models (
    model_id        VARCHAR(255) PRIMARY KEY NOT NULL,
    name            VARCHAR(255) NOT NULL,
    domain          VARCHAR(255) NOT NULL,
    focus           TEXT,
    description     TEXT
);

DROP TABLE IF EXISTS comparisons;
CREATE TABLE comparisons (
    comparison_id       INTEGER PRIMARY KEY AUTOINCREMENT,
    model_id_1          VARCHAR(255) NOT NULL,
    model_id_2          VARCHAR(255) NOT NULL,
    comparison_timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
    user_session_id     VARCHAR(255),
    FOREIGN KEY (model_id_1) REFERENCES models (model_id),
    FOREIGN KEY (model_id_2) REFERENCES models (model_id)
);

DROP TABLE IF EXISTS inferred_connections;
CREATE TABLE inferred_connections (
    connection_id   INTEGER PRIMARY KEY AUTOINCREMENT,
    comparison_id   INTEGER NOT NULL,
    connection_text TEXT NOT NULL,
    connection_type VARCHAR(100),
    confidence_score DECIMAL(3,2),
    generated_by_ai BOOLEAN,
    timestamp       DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (comparison_id) REFERENCES comparisons (comparison_id)
);

DROP TABLE IF EXISTS questions_and_hypotheses;
CREATE TABLE questions_and_hypotheses (
    question_id         INTEGER PRIMARY KEY AUTOINCREMENT,
    question_text       TEXT NOT NULL,
    submitted_by_user_id VARCHAR(255),
    submission_timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
    related_comparison_id INTEGER,
    FOREIGN KEY (related_comparison_id) REFERENCES comparisons (comparison_id)
);
"""

DATABASE_FILE = PROJECT_ROOT / "jennai_db.sqlite"

def connect_db():
    return sqlite3.connect(DATABASE_FILE)

def initialize_database():
    if not DATABASE_FILE.parent.exists():
        DATABASE_FILE.parent.mkdir(parents=True, exist_ok=True)
    conn = None
    try:
        conn = connect_db()
        cursor = conn.cursor()
        cursor.executescript(DB_SCHEMA_CONTENT)
        conn.commit()
        color_print([("green", f"Database '{DATABASE_FILE.name}' initialized and tables created successfully.")])
    except sqlite3.Error as e:
        color_print([("red", f"Database error during initialization: {e}")])
    finally:
        if conn:
            conn.close()

def populate_mock_models():
    conn = None
    try:
        conn = connect_db()
        cursor = conn.cursor()
        cursor.execute("DELETE FROM models")
        for name, domain, focus in ALL_MOCK_LLMS_LIST:
            model_id = f"{domain.split()[0].lower()}-{name.replace(' ', '-').lower()}"
            cursor.execute(
                "INSERT INTO models (model_id, name, domain, focus, description) VALUES (?, ?, ?, ?, ?)",
                (model_id, name, domain, focus, f"Mock LLM focused on {focus} within {domain} domain.")
            )
        conn.commit()
        color_print([("green", f"Successfully populated 'models' table with {len(ALL_MOCK_LLMS_LIST)} mock LLMs.")])
    except sqlite3.Error as e:
        color_print([("red", f"Database error during model population: {e}")])
    finally:
        if conn:
            conn.close()

def create_mock_llm_file():
    if not LLM_SAMPLES_DIR.exists():
        LLM_SAMPLES_DIR.mkdir(parents=True, exist_ok=True)
    with open(MOCK_LLM_FILE, "w") as f:
        f.write(MOCK_LLM_CONTENT)
    color_print([("green", f"Successfully created mock LLM definition file: {MOCK_LLM_FILE}")])

def destroy_mock_llm_data():
    print(f"Attempting to destroy mock LLM data in: {SAMPLES_ROOT}")
    if MOCK_LLM_FILE.exists():
        try:
            os.remove(MOCK_LLM_FILE)
            color_print([("green", f"Successfully destroyed mock LLM file: {MOCK_LLM_FILE}")])
        except OSError as e:
            color_print([("red", f"Error destroying mock LLM file: {e}")])
    else:
        print(f"Skipping destruction: {MOCK_LLM_FILE} does not exist.")
    if DATABASE_FILE.exists():
        try:
            os.remove(DATABASE_FILE)
            color_print([("green", f"Successfully destroyed database file: {DATABASE_FILE}")])
        except OSError as e:
            color_print([("red", f"Error destroying database file: {e}")])
    else:
        print(f"Skipping destruction: {DATABASE_FILE} does not exist.")
    if not MOCK_LLM_FILE.exists() and not DATABASE_FILE.exists():
        print("No mock LLM data files or database found. Nothing to destroy.")
    else:
        print("Mock LLM data destruction process complete.")

def print_header(title: str):
    print("\n" + "=" * 70)
    print(f"{title}")
    print("=" * 70)

def main():
    print_header("JennAI Data Samples Admin Console")
    MENU = [
        Choice("install_data", "Install Mock LLM Data and Database (Create)"),
        Choice("destroy_data", "Destroy Mock LLM Data and Database (Destroy)"),
        Separator(),
        Choice("exit", "Exit"),
    ]
    while True:
        try:
            selection = inquirer.select(
                message="Select a data sample task:",
                choices=MENU,
                default="install_data",
                qmark=">",
                cycle=False,
                max_height=10,
            ).execute()
            if selection == "install_data":
                print_header("Installing Mock LLM Data")
                destroy_mock_llm_data()
                initialize_database()
                populate_mock_models()
                create_mock_llm_file()
                color_print([("green", "\nMock LLM data installation complete.")])
                input("\nPress Enter to return to the menu...")
            elif selection == "destroy_data":
                print_header("Destroying Mock LLM Data")
                destroy_mock_llm_data()
                color_print([("green", "\nMock LLM data destruction complete.")])
                input("\nPress Enter to return to the menu...")
            elif selection == "exit":
                print("\nGoodbye!")
                break
        except KeyboardInterrupt:
            color_print([("red", "\nOperation cancelled by user.")])
            break

if __name__ == "__main__":
    main()